## Какие существуют уровни веб-приложения и за что отвечает каждый из них?  
Современные веб-приложения имеют многоуровневую архитектуру, состоящую из уровней представления, бизнеса, сохранения и базы данных. Небольшие приложения имеют три уровня, где в некоторых случаях бизнес-уровни и уровни сохраняемости действуют вместе, а сложные приложения имеют пять или шесть уровней.

**Уровень представления**, построенный с помощью HTML, CSS, JavaScript и их фреймворков, обеспечивает связь между интерфейсом и браузером для облегчения взаимодействия с пользователем.  
**Бизнес-логики** определяет бизнес-логику и правила. Он обрабатывает запросы браузера, выполняет бизнес-логику, связанную с запросами, а затем отправляет их на уровень представления.  
**Уровень обслуживания данных** отвечает за доступ к данным. Он тесно связан с бизнес-логики и имеет сервер базы данных, который извлекает данные с соответствующих серверов.  
**Уровень базы данных или уровень доступа к данным** содержит все данные и обеспечивает безопасность данных, отделяя бизнес-логику от клиентской стороны.  

Каждый из этих слоев работает независимо от другого. Компоненты одного слоя закрыты и имеют дело с логикой связанного слоя.  Например, компоненты, находящиеся на уровне представления, имеют дело с логикой представления, а компоненты бизнес-логики — с бизнес-логикой. Такая схема работы снижает потенциальную нагрузку, когда в веб-приложении требуются изменения. Поэтому изменения могут быть внесены в один слой, не затрагивая компоненты других слоев.   

## Что такое монолитная и микросервисная архитектуры веб-приложения? Каковы различия между монолитом и микросервисами?  

**Традиционная монолитная архитектура** веб-приложения состоит из трех частей - базы данных, клиентской и серверной сторон. Это означает, что внутренняя и внешняя логика, как и другие фоновые задачи, генерируются в одной кодовой базе. Чтобы изменить или обновить компонент приложения, разработчики программного обеспечения должны переписать все приложение.

**Микросервисная архитектура** - этот подход, который позволяет разработчикам создавать веб-приложение из набора небольших сервисов. Разработчики создают и развертывают каждый компонент отдельно.

Архитектура микросервисов выгодна для больших и сложных проектов, поскольку каждый сервис может быть изменен без ущерба для других блоков. Поэтому, если вам нужно обновить логику оплаты, вам не придется на время останавливать работу сайта.

Известные проекты: Netflix, Uber, Spotify, PayPal.



## Почему не все приложения построены на микросервисной архитектуре?  

-   Иногда нужно быстро что-то написать и выложить, чтобы начать работу. В этом случае мы не знаем, выстрелит проект или нет, поэтому делать сразу микросервисы — оверинжиниринг. Обычно ждут первых результатов, а затем уже принимают архитектурные решения.

При кажущейся простоте и логичности деление большого монолитного приложения на самостоятельные сервисы — сложная техническая задача. Сам микросервисный подход не лишён недостатков, а его плюсы могут оборачиваться минусами:  

-   Сложнее осуществлять мониторинг. Монолит один, и отслеживать, как он работает проще. Микросервисов сотни, а иногда тысячи, и уследить за каждым физически невозможно. Поэтому приходится уделять много внимания системам управления и мониторинга.  

-   Каждый микросервис может использовать тот язык программирования и те технологии, что удобны команде, которая его разрабатывает. С одной стороны, это плюс — какие-то фреймворки и языки лучше заточены под конкретные вещи. Если мы делаем сервис обработки изображений или машинного обучения, можем не заострять внимание на технологиях монолита, а выбрать решение под задачу. С другой стороны, это минус — нужно как-то конфигурировать все микросервисы между собой и поддерживать «зоопарк» технологий.   

-   Снижение доверия. Когда у нас сотни узлов, могут возникать проблемы с аутентификацией и авторизацией, поскольку есть вероятность подсоединения мошенников.   

-   Сложности развёртывания. Чтобы требования по отказоустойчивости выполнялись, микросервисы нужно развёртывать на отдельных серверах. И здесь не работает подход: «Берём приложение, ставим и запускаем». Нужны системы оркестрации и деплоймента.   

Вывод: Невозможно сказать, что один способ архитектуры лучше другого, каждый из них решает свои задачи в зависимости от конкретногопроекта и его требований. И если приложение небольшое и не нуждается в масштабировании, то монолитная архетектура будет достаточно эффективна. 

## Особенности тестирования
1. тестирование MOA (микросервисно-ориентированных приложений) должно происходить как на микроуровне, так и на макроуровне.   
2. На микроуровне каждый сервис должен быть досконально протестирован в пределах своей зоны ответственности. Согласно некоторым трактовкам, границей микросервиса считается функция.  
3. Наряду с тестированием функциональности микросервиса, также необходимо позаботиться о тестировании единицы развертывания, в рамках которой происходит релиз микросервиса. Как правило, микросервисы развертываются в виде контейнеров в рамках той или иной технологии оркестрации, например, Kubernetes или Docker Swarm. Важный аспект оркестрации контейнеров – обеспечение долговременной устойчивости микросервисов.

Считается, что микросервисы могут отваливаться по целому ряду причин, как из-за отказа хоста, так и из-за ошибок самого микросервиса. Вполне нормально, что в ходе одновременной эксплуатации тысяч контейнеров возникают какие-то текущие неисправности. Важность тестирования в том, что правильный выход микросервиса из игры не менее важен, чем его корректное функционирование. Тесты на микроуровне гарантируют, что микросервис будет аккуратно оживать и аккуратно умирать, при любом масштабе системы.  

4. Целесообразно уделить особое внимание функции внутри микросервиса, учитывая нарастающую популярность бессерверной парадигмы, согласно которой микросервис нужно представлять только как единственную функцию. Но многие практикующие тестировщики при работе с микросервисами склонны ограничиваться модульными тестами. Тогда как модульный тест нормально покрывает единственную функцию, работающую в очень ограниченных тестовых условиях, микросервис рассчитан на обслуживание аудитории в рамках всего Веба. Поэтому условия тестирования должны быть экстремальными.

Например, в рамках хорошего теста на микроуровне можно одновременно прогнать сто тысяч экземпляров микросервиса и посмотреть, как они поведут себя в таком масштабе. Недостаточно за раз проверять всего одну функцию, применяя к ней единственный модульный тест. Необходимо прогонять такие тесты на тысячах экземпляров функции одновременно, с учетом показателей хостинговой среды, в которой придется работать.

5. Тесты также должны гарантировать, что все существенные события, происходящие в микросервисе, как следует логируются – и, что не менее важно, эти записи логов можно понять. В мире микросервисов записи логов очень важны, в особенности это касается асинхронных MOA, где нет последовательного выполнения поведений. Зачастую только данные логов помогут вам осмыслить, что же творится в приложении.  

6. Независимо от того, является ли MOA синхронным, асинхронным или гибридным, ему показан режим тщательного тестирования. При тестировании микросервисов на макроуровне необходимо убедиться, что два аспекта не вызывают нареканий: межсервисная коммуникация и процессы развертывания.

7. Микросервисы по определению независимы друг от друга. Они определяют, что им делать, исходя из получаемой ими информации, поэтому точность межсервисной коммуникации критически важна для целостной эксплуатации микросервисно-ориентированного приложения.

Обеспечение межсервисной коммуникации означает организацию того, чтобы правильная информация приходила откуда нужно и уходила куда нужно. Тесты должны позволять отслеживать, как происходит обмен сообщениями, и как они обрабатываются. Это верно как для коммуникации по HTTP в режиме «запрос-отклик», так и для обмена асинхронными сообщениями, распространяемыми через брокер сообщений. Тестирование должно помочь убедиться, что поддерживаются форматы сообщений, обеспечивающие положительный путь работы системы, а неверно отформатированные сообщения отклоняются, причем с достаточными объяснениями (а не просто с ошибкой «плохое сообщение»).

8. Здраво организованные процессы непрерывной интеграции и непрерывного развертывания (CI/CD) важны в любой парадигме разработки ПО, но, когда речь заходит о микросервисных приложениях, эффективный, точный и быстрый процесс CI/CD критически важен. MOA могут проходить ревизию в темпе сотен обновлений ежедневно, поэтому один микросервис, сборка которого запаздывает, может стать узким местом и затормозить весь процесс релиза.

Наилучший способ от этого перестраховаться – дать тестированию конвейера CI/CD тот же приоритет, что и любому другому высокоуровневому режиму тестирования. Выявление и исправление таких проблем как замедленная сборка микросервисов из-за артефактов в коде, медленное предоставление сред выполнения, в которых хостятся микросервисы, а также медленное поднятие уже развернутых микросервисов – необходимые предпосылки для обеспечения работоспособности конвейера CI/CD. Даже если микросервис сложен как шаттл, от него будет мало пользы, если вы не сможете быстро развертывать и пускать в ход операционные единицы.

## Тестирование монолитного приложения

1.   Простота тестирования
Вы тестируете каждый сервис независимо от каких-либо зависимостей. Обычно все очевидно.
2.   Часто каждая команда имеет свою собственную выделенную среду тестирования, чтобы обеспечить изоляцию процесса разработки и тестирования функций от постоянных прерываний изменениями других команд. Это, в свою очередь, внесет определенный уровень избыточности тестирования в процесс выпуска релиза, поскольку теперь изменения должны быть дважды проверены в рамках изменений релиза.




